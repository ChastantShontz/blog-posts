<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>post2</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="blog-post-2">Blog Post 2</h2>
<h3 id="february-10-2022">February 10, 2022</h3>
<p>As mentioned in the previous blog post, the field of web development
is very diverse and requires collaboration between people of all
different specialties. There are UX designers that create the stylized
look of the website, web developers that bring it to life with code,
information architects that map out a wireflow of all the different web
pages, and user testers that test the product against potential
users.</p>
<p>There are also the system architects, who oversee the organizational
structure of their projects. There are two main structure types:
monoliths and microservices. However, there is a large spectrum between
these two, and most projects fall somewhere in the middle.</p>
<p>The names of these structures are fairly self-explanatory. In a
monolith, the entire website is built by the same team and contained in
one massive, overarching system. It is designed to be a single,
self-sufficient program, all the components of which are
interconnected.</p>
<p>In microservices, the opposite is true. Instead of one larger system,
the project is split up into many smaller ones, each built by a separate
team of developers. All of these programs are still connected, albeit
much more loosely, and come together to form the final product.</p>
<figure>
<img src="img/monolithVsMicroservices.png"
alt="A monolith vs microservices" />
<figcaption aria-hidden="true">A monolith vs microservices</figcaption>
</figure>
<p>There are pros and cons to both of these approaches.</p>
<p><strong>Monolith:</strong></p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Easier to build in the beginning</td>
<td>More vulnerable to breaking</td>
</tr>
<tr class="even">
<td>Whole thing can be changed at once</td>
<td>Difficult to change in later stages</td>
</tr>
</tbody>
</table>
<p><strong>Microservices”</strong></p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Changes limited to their area</td>
<td>Takes a while to get started</td>
</tr>
<tr class="even">
<td>Easier to modify in later stages</td>
<td>Requires more coordination between groups</td>
</tr>
</tbody>
</table>
<p>A monolith is easier to build in the short term because it is easier
to coordinate a single cohesive team than many individual ones. This
allows communication to be streamlined, and different parts of the
project are more consistent with each other.</p>
<p>However, in the long term, monoliths are not nearly as convenient.
Once set, they are more difficult to change, as a change to one aspect
of it affects the entire structure. If something is changed in a certain
place, it must also be changed everywhere else to maintain consistency.
This makes it more vulnerable to breaking.</p>
<p>One of the reasons that microservices are so popular is that they
solve many of these problems posed by monoliths. The fact that all their
systems are developed independently gives them greater flexibility to be
changed in later stages. A change in one area is contained there and
will not necessarily affect the entire program.</p>
<p>On the other hand, though, microservices are significantly harder to
get off the ground. They require a great deal of coordination between
multiple teams, each with their own specialties and goals. Once built,
they are very useful, but initially, they can be very hard to get off
the ground.</p>
<p>The takeaway from all this is that monoliths and microservices are
both useful in different circumstances. Monoliths work best when it is a
smaller project, one that does not need to be broken up into separate
programs. At a certain size, microservices are more trouble than they’re
worth and might as well be combined.</p>
<p>Microservices are ideal with larger-scale systems that would be too
inconvenient to combine into the same program. Once they reach a certain
size, the hassle of needing to modify everything whenever a change is
implemented negates the benefits of everything being interconnected.
There is no one-size-fits-all, though, and most projects fall somewhere
in the middle of these two extremes.</p>
</body>
</html>

<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>post3</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h2 id="blog-post-3">Blog Post 3</h2>
<h3 id="february-21-2022">February 21, 2022</h3>
<p>The testing phase of a project is arguably just as important as the
building phase, for this is where you see if all your hard work yielded
the desired results. There are many different methods of testing, each
one of which is applicable in a different situation.</p>
<p>The two main schools of thought are test-driven development and
behavior-driven development. In test-driven development, you use
something called the red-green refactor cycle, which is where you first
write the code so that it fails, before writing the minimum amount of
additional code to make it succeed.</p>
<p>The code in these tests are structured according to
arrange-act-assert, also called given-when-then. The “arrange/given”
part sets up the conditions, the “act/when” part completes the action,
and the “assert/then” part verifies that it was a success.</p>
<p>These tests can take the form of unit testing, which tests only one
function at a time, integration testing, which tests more than one
function, and end-to-end testing, which tests the entire system at once.
Because of their complexity, end-to-end tests are the slowest to run.
They have their uses, though, for even if several individual functions
pass their respective unit tests, they might not work with each other
correctly.</p>
<p>Another approach is property-based testing, where instead of giving
specific examples for the input, you input a wide array of values at
once. You can keep this up until you find the values that make the
functions fail, and then compare it to the accepted margin of error.</p>
<p><strong>Test-Driven Development:</strong></p>
<div class="line-block">Unit test | Tests a single function |<br />
Integration test | Tests multiple functions |<br />
End-to-end test | Tests the entire system |<br />
Property-based test | Tests with multiple values at once |</div>
<p>With behavior-driven development, on the other hand, instead of
testing on the level of individual functions, you test the system as a
whole based on a predetermined set of acceptance criteria. These
criteria are drawn up by the “three amigos,” which refers to the product
representative, the developer, and the tester.</p>
<p>All three of these individuals have their own role to play. The
product representative brings up potential flaws in the system, the
developer writes the code to fix it, and the tester ensures that this
problem has indeed been fixed. Others can contribute, like the project
shareholders, but these are the main three.</p>
<p>While it may be easier and faster to automate tests, there are times
where this is not as practical, and testing must be done manually. The
two subcategories of manual testing are functional testing, which
ensures that the new changes behave as expected, and regression testing,
which ensures that the working of previous functions are not broken by
said changes.</p>
<p>Visual testing, rather than testing the functionality of a webpage,
instead tests to make sure that it looks the way it is supposed to. This
is another area of testing that almost always has to be done manually.
As simple as it sounds, the most effective way is to simply rely on
humans to tell you what they think.</p>
<p>It is possible to automate visual testing, but this is not very
practical and often more trouble than it is worth. Often, automated
visual tests will compare a previous screenshot of the page that was
deemed passable with a newly taken screenshot to find the new changes.
It analyzes the position and color of elements on a page to see if they
meet the acceptance criteria.</p>
<p>Sometimes, instead of the “three amigos,” there will be multi-purpose
testers called quality analysts. They conduct exploratory testing, which
is where they try to get inside the heads of the users and follow the
path that they would most likely take, rather than the path that the
developers expect them to follow.</p>
<p>Finally, there is cross-functional testing, meant to test general
requirements such as accessibility and security. An example of this are
load tests, also called volume tests, which tests to see if a website
will function under large amounts of user traffic. The amount of traffic
that is tested against here is relative, calculated based on what type
of website it is. Sometimes, testers will increase the traffic level
until the website crashes to see if it reaches an acceptable
threshold.</p>
<p>The big drawback to load tests is that the prototype website often
runs on different software than the final product, so they are not
always accurate. To fix this, some companies run load tests on their
website once they have already been completed.</p>
<p><strong>Behavior-Driven Development:</strong></p>
<div class="line-block">Functional test | Tests that new changes work
|<br />
Regression test | Tests that old functions are not broken |<br />
Visual test | Tests that the webpage looks good |<br />
Exploratory test | Tests according to what the users would do |<br />
Cross-functional test | Tests general requirements |</div>
</body>
</html>
